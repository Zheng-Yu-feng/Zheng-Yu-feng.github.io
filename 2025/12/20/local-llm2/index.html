<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>local_llm（详细设计） | Yufeng's blog</title><meta name="author" content="Zheng Yufeng,3054661346@qq.com"><meta name="copyright" content="Zheng Yufeng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="详细设计：使用Flask+VUE搭建本地大语言模型">
<meta property="og:type" content="article">
<meta property="og:title" content="local_llm（详细设计）">
<meta property="og:url" content="http://example.com/2025/12/20/local-llm2/index.html">
<meta property="og:site_name" content="Yufeng&#39;s blog">
<meta property="og:description" content="详细设计：使用Flask+VUE搭建本地大语言模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/image/local_llm.png">
<meta property="article:published_time" content="2025-12-20T08:05:15.000Z">
<meta property="article:modified_time" content="2025-12-20T09:10:54.114Z">
<meta property="article:author" content="Zheng Yufeng">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="Interactive system">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image/local_llm.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "local_llm（详细设计）",
  "url": "http://example.com/2025/12/20/local-llm2/",
  "image": "http://example.com/image/local_llm.png",
  "datePublished": "2025-12-20T08:05:15.000Z",
  "dateModified": "2025-12-20T09:10:54.114Z",
  "author": [
    {
      "@type": "Person",
      "name": "Zheng Yufeng",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/12/20/local-llm2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'local_llm（详细设计）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yufeng's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/local_llm.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Yufeng's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">local_llm（详细设计）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">local_llm（详细设计）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-20T08:05:15.000Z" title="发表于 2025-12-20 16:05:15">2025-12-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-20T09:10:54.114Z" title="更新于 2025-12-20 17:10:54">2025-12-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/project/">project</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><strong>项目背景</strong>：在数据安全与隐私保护成为企业数字化核心关切的时代，公有云AI服务因其在敏感数据合规性、网络依赖性及定制灵活性方面的局限，难以满足高安全隔离场景的需求。为此，本项目旨在设计并实现一套支持完全私有化部署、开箱即用的大语言模型交互工具系统。该系统允许用户在离线或隔离环境中，安全、自主地进行智能对话、文档分析与知识问答，从根本上满足企业“数据不出域、模型可自选、部署可迁移”的核心诉求，并确保在Windows与Linux平台中的稳定集成与高效运行。</p>
<p><strong>项目范围</strong>：本项目将交付一个功能完整、支持跨平台运行的大语言模型交互工具，具体涵盖以下核心模块与功能：</p>
<p>（1）灵活输入与交互界面：提供生成式智能问答会话窗口，支持纯文本输入与文档上传（支持TXT、MD格式）两种输入方式，实现多模态交互。</p>
<p>（2）跨平台与部署支持：支持在Windows与Linux操作系统环境中通过API进行集成与调用。</p>
<p>（3）私有化部署：提供标准化私有化部署方案，便于迁移至不同服务平台。</p>
<p>（4）多模型集成与管理：集成6种参数规模≥7B的大语言模型（Qwen、Baichuan、Yi、Mistral、Zephyr、九格）。支持API调用，用户可通过有效密钥调用模型，兼容公有模型服务。</p>
<p>（5）输出控制与参数调节：提供采样策略（如temperature、top_p、top_k）与生成长度（max_length）等可调节参数界面，实现对模型输出内容与行为的精细化控制。</p>
<p>（6）响应性能记录与监控：具备模型响应时间与输出速度的记录功能，支持性能跟踪与优化分析。</p>
<p>（7）用户界面与体验：基于Vue 3与Element Plus构建现代化、响应式的图形界面，确保交互流程直观、操作简单易懂。</p>
<p>（8）多会话上下文管理：支持创建、保存、切换多个独立对话会话，确保各会话上下文隔离且持久化存储。</p>
<p>（9）对话历史与导出：完整记录所有对话历史，支持以Markdown或JSON格式导出，便于审计与知识留存。</p>
<p>（10）系统可维护性与可升级性：采用标准化开发与部署框架，保障系统具备良好的可维护性与可扩展性，支持快速故障修复与平滑版本升级。</p>
<h1 id="二、总体设计概述"><a href="#二、总体设计概述" class="headerlink" title="二、总体设计概述"></a>二、总体设计概述</h1><h2 id="2-1-系统架构"><a href="#2-1-系统架构" class="headerlink" title="2.1 系统架构"></a>2.1 系统架构</h2><p>本系统采用前后端分离的单体应用架构，所有组件运行在同一个用户进程中。前端是使用现代Vue 3技术栈构建的单页面应用（SPA），后端是Python Flask服务器，两者通过RESTful API进行通信。本系统采用清晰的分层架构设计，旨在实现关注点分离、模块化以及良好的可维护性。整体架构自上而下可分为表现层、Web服务层、业务逻辑层与大语言模型层，各层通过定义良好的接口进行通信，共同协作以提供完整的私有化大语言模型交互体验：</p>
<p><img src="/../image/clip_image002.jpg" alt="img"></p>
<p>图1 系统架构图</p>
<p><strong>表现层</strong>：作为用户直接交互的界面，承担着渲染视图、管理用户状态与处理交互事件的核心职责。该层基于现代前端技术栈构建：使用 Vue 3 框架及其响应式系统（如 reactive）与组合式 API（Composition API）来构建高度动态和响应式的用户界面组件。Vue Router 负责管理整个单页面应用（SPA）的路由导航，定义了诸如 &#x2F;login（登录）、&#x2F;chat（主聊天界面）、&#x2F;set_model（模型选择）、&#x2F;change_parameters（参数调整）、&#x2F;upload（文件上传）等一系列路由路径，确保用户操作能无缝切换到对应的功能视图。应用状态由 Pinia 进行集中式管理，其存储（Store）中维护着包括当前用户认证状态、所有聊天会话的列表及其激活状态、每个会话内完整的消息历史记录、系统当前可用的大语言模型列表与用户选中的模型配置、以及各类模型采样参数（如 temperature, top_p 等）在内的全局状态。所有与后端服务的 HTTP 通信均通过 Axios 库完成，它负责发送 RESTful API 请求并处理响应。界面组件主要采用 Element Plus 组件库进行构建，以快速实现美观、一致且易于使用的聊天界面、表单、弹窗等元素。此外，Nanoid 库被用于在前端生成唯一标识符（如会话 ID、消息 ID），保证客户端数据标识的独立性与唯一性。</p>
<p><strong>Web</strong> <strong>服务器层</strong>: 充当了前端应用与后端业务逻辑之间的桥梁和静态资源托管者。该层以 Flask 轻量级 Web 框架为核心实现。其主要职责之一是托管由 Vue 3 项目构建后产生的静态文件（包括 HTML、JavaScript 和 CSS），为前端 SPA 提供服务。同时，Flask 应用实现了一套完整的 RESTful API 接口（例如 &#x2F;api&#x2F;login, &#x2F;api&#x2F;chat, &#x2F;api&#x2F;models 等），供前端 Axios 调用。此层接收前端的请求，进行初步的验证与转发，并将业务逻辑层的处理结果封装成 JSON 响应返回给前端。为了提升会话上下文管理的性能与持久化能力，该层集成了 Redis 作为缓存数据库，主要用于存储用户的历史对话消息。当用户进行连续对话时，系统可以从 Redis 中快速读取历史上下文，并将其组合到新的提示词中，从而使得大语言模型能够基于完整的对话历史进行连贯、准确的回答。</p>
<p><strong>业务逻辑层</strong>:是应用程序的核心，封装了所有关键的业务规则与处理流程。它独立于 Web 框架的具体实现，包含一系列协调不同功能的处理器或服务模块。认证管理模块负责校验用户通过前端提交的登录凭证，确保系统访问的安全性。会话管理模块在服务端内存中维护着所有活跃聊天会话的数据结构，每个会话对象不仅包含其元信息，还关联着完整的消息历史链。消息处理模块负责接收来自前端的用户输入（无论是纯文本还是经由文档解析后的文本内容），并依据当前会话 ID 从 Redis 中获取历史消息，随后将当前 query 与历史上下文智能地组合、拼接成符合特定大语言模型要求的提示（Prompt）格式。模型调用器（Model Invoker）是本层的一个关键组件，它对外提供统一的调用接口（如 generate(prompt, parameters)），业务逻辑通过此接口与底层的大语言模型层交互，从而屏蔽了不同模型在加载、推理细节上的差异。此外，导出逻辑模块负责将用户指定的会话历史，按照要求转换为结构化的 Markdown 文档或 JSON 数据格式，并生成可供下载的文件。</p>
<p><strong>大语言模型层</strong>: 是系统的智能引擎，直接负责文本的生成任务。该层基于 Hugging Face Transformers 库构建，负责加载、管理在本地面部部署的多个大型语言模型（如 Qwen、Baichuan、Yi、Mistral、Zephyr、九格等）。鉴于大模型对内存和显存资源消耗巨大，本层实现了一套精细的模型缓存与生命周期管理策略。这包括：在应用启动时预加载一个或多个最常用的默认模型以加快首次响应速度；支持按需加载，即当用户在前端切换模型时，再动态加载对应的模型至内存；以及基于最近最少使用（LRU） 算法的缓存管理，在设定的内存阈值下，自动卸载最久未被使用的模型，以维持系统整体的资源平衡。该层对外提供统一的文本生成函数，能够接收来自业务逻辑层的提示文本和各种生成参数（如 temperature、top_p、top_k、max_length 等），并调用相应模型进行推理，最后将生成的文本结果返回。</p>
<h2 id="2-2技术栈"><a href="#2-2技术栈" class="headerlink" title="2.2技术栈"></a>2.2技术栈</h2><p>在技术栈的选择上，本项目充分考虑了功能性、性能、开发效率以及私有化部署的要求。</p>
<p>后端技术栈以 Python 3.10+ 为主要开发语言，因其在人工智能和数据处理领域的丰富生态。Web 服务框架选用 Flask，其轻量、灵活的特性非常适合构建此类以 API 为核心的中间层服务，便于快速开发和维护 RESTful 接口。模型推理的核心依赖于 Hugging Face Transformers 库，并搭配 PyTorch 或 TensorFlow 作为底层计算框架，这为加载和运行各种开源大语言模型提供了标准化支持。为处理用户上传的多种格式文档（如txt、md），集成了对应文档解析库，用于提取纯文本内容。数据序列化主要使用 Python 原生的 json 模块。为高效管理对话状态，选择 Redis 作为高速缓存数据库，存储会话历史，确保上下文快速存取。</p>
<p>前端技术栈围绕构建现代化、高性能的单页面应用展开。选用 Vue 3 作为核心框架，并主要使用其组合式 API（Composition API） 进行开发，以更好地组织复杂组件的逻辑并提高代码的可复用性。应用状态由 Pinia 管理，它提供了比 Vuex 更简洁、类型友好的 API。路由控制由 Vue Router 处理，以实现多视图间的无缝跳转。用户界面基于 Element Plus（适配 Vue 3 的版本）进行构建，大幅提升了开发效率并保证了视觉一致性。所有 HTTP 请求通过 Axios 发起，它提供了强大的拦截器、错误处理等功能。唯一 ID 的生成使用轻量的 Nanoid 库。整个前端项目使用 Vite 作为构建工具与开发服务器，它提供了极快的冷启动和模块热更新（HMR）体验。开发语言采用 TypeScript，通过静态类型检查来增强代码的健壮性和可维护性。</p>
<p>模型管理策略是项目成功的关键。所有集成的模型均需转换为或本身即为 Hugging Face Transformers 库支持的格式，确保加载接口的统一。初始支持的模型列表包括 Qwen, Baichuan, Yi, Mistral, Zephyr, 九格等，并保留了扩展接口。模型缓存策略的设计紧密结合硬件资源（GPU&#x2F;CPU 内存），动态管理模型的加载与卸载，在用户体验（减少等待）与资源占用之间取得平衡。</p>
<p>数据流与存储方案遵循简洁高效的原则。前后端之间通过基于 JSON 格式的 HTTP（RESTful） 协议进行通信。运行时的大部分动态数据（如前端状态、后端会话对象）存储在内存中，分别由前端的 Pinia Store 和后端的 Python 数据结构进行管理。对于数据的持久化，主要依赖于用户主动触发的导出操作，将对话历史保存为 Markdown 或 JSON 文件至本地磁盘，而非在服务端进行自动化的数据库持久化，这符合工具类应用及隐私保护的设计初衷。</p>
<p>开发与部署流程采用前后端分离的模式。在开发阶段，前端 Vite 开发服务器通过配置代理将 API 请求转发至后端的 Flask 开发服务器，方便并行开发和调试。构建时，前端代码通过 vue build（或 vite build）命令编译成静态文件。随后，这些静态文件被复制到 Flask 应用指定的静态文件目录中，形成可独立部署的整体。为达成“开箱即用”的私有化部署目标，最终封装方案考虑使用 PyInstaller 将整个 Python 后端及其依赖、前端静态资源打包成一个独立的可执行文件；同时，也支持使用 Docker 进行容器化部署，以增强环境一致性和迁移便利性。应用启动后，将自动加载模型、启动内嵌的 Flask Web 服务器，并可选择自动打开系统默认浏览器导航至本地应用地址，为用户提供一体化的启动体验。</p>
<h2 id="2-3-关键设计考虑"><a href="#2-3-关键设计考虑" class="headerlink" title="2.3 关键设计考虑"></a>2.3 关键设计考虑</h2><p>在系统设计过程中，以下几个关键问题需要特别关注，并制定了相应的解决方案：</p>
<p>内存与模型资源管理是首要挑战。大型语言模型参数庞大，同时加载多个模型极易耗尽系统内存。为此，我们设计了动态的模型加载策略：结合“预加载”、“按需加载”和“LRU缓存淘汰”机制。该策略的核心在于精细化的生命周期控制。具体而言，当用户在前端界面切换模型时，后端业务逻辑层会首先检查目标模型是否已加载在内存中。若未加载，则从磁盘加载；若已加载，则直接激活。至关重要的优化环节发生在模型卸载时：系统会显式地释放当前已加载模型实例所占用的资源。这通过执行del self.current_instance来删除Python对象引用，并紧接着调用torch.cuda.empty_cache()来强制清空PyTorch在CUDA设备上占用的、现已不再引用的缓存内存。这一组合操作能即时、有效地回收珍贵的GPU显存，为加载下一个模型腾出空间，从而在有限的硬件资源下支持多个大型模型的动态切换。在用户界面中，当模型处于加载、卸载或切换状态时，会提供明确的视觉反馈（如加载指示器、进度提示），让用户感知当前系统状态，提升操作的可预期性与流畅度。</p>
<p>前后端状态同步是保证应用一致性的基础。前端以 Pinia Store 作为状态的“单一数据源”，所有组件都从中读取状态。而后端业务逻辑层也维护着相应的会话与消息状态。两者之间通过严谨的 API 调用契约保持同步：前端的每一个可能改变状态的操作（如发送消息、切换模型）都会触发一个 API 调用，后端处理成功后，会在响应中返回最新的、权威的状态数据（或至少返回成功标识），前端随后根据响应结果更新本地的 Pinia Store，从而确保两端状态的一致。</p>
<p>文件上传与内容处理流程需要完整的设计。流程始于前端通过 &lt; input type&#x3D;”file” &gt; 元素选择文件并上传至后端 &#x2F;api&#x2F;upload 接口。后端接收文件后，根据其扩展名（如 .md, .txt）分发给相应的文档解析库进行文本内容提取。提取出的纯文本经过必要的清洗与格式化后，或直接作为一条用户消息放入会话上下文，或与用户提出的具体问题一同组合成新的提示词，最终提交给大语言模型进行处理和问答。</p>
<p>全面的错误处理机制是保障系统健壮性的关键。设计涵盖了从模型加载失败、文本生成过程中出现异常、到网络连接中断、用户输入无效、文件解析错误等各种可能的情况。后端 API 会捕获这些异常，并将其转化为结构化的错误信息（包含错误码和描述）返回给前端。前端 Axios 的拦截器会统一捕获 HTTP 错误和业务错误，并调用 Element Plus 的通知或消息框组件，向用户展示友好、明确的错误提示，指导用户进行后续操作。</p>
<p>后台推理任务与界面响应性是提升用户体验的重要方面。考虑到大语言模型推理可能是耗时较长的任务（数秒甚至数十秒），如果在Flask的主同步线程中直接执行生成调用，将会完全阻塞该工作进程，使其无法处理任何其他请求（如界面点击、历史查询），导致应用“卡死”。因此，我们将耗时的模型生成任务设计为异步后台任务。当用户发送一条消息后，后端API接口会立即接收请求并快速验证，随后将此生成任务提交至一个独立的后台线程或异步任务队列中执行，主线程则立即返回一个“任务已接收”的响应。前端据此可更新界面状态。这种异步化与解耦的设计确保了Web服务器主线程能够持续保持高响应速度，及时处理用户的其它交互操作，从而在整体上维持了应用的流畅性和可用性。</p>
<p>对话历史的完整性保障直接影响到多轮对话的质量。我们选择 Redis 作为历史消息的存储介质，主要是看中其高性能的内存读写特性，能够支持快速的上下文拼接。每次进行新的对话时，系统会从 Redis 中准确检索出该会话的所有历史消息，确保模型获得的上下文是完整且连续的。这种设计既满足了对话一致性的需求，又通过外部缓存减轻了业务逻辑层长期维护大量内存数据的压力。</p>
<h1 id="三、模块设计"><a href="#三、模块设计" class="headerlink" title="三、模块设计"></a>三、模块设计</h1><p>本章深入阐述系统核心功能模块的详细设计方案。基于总体架构，系统被分解为六个高内聚、低耦合的关键模块：认证、会话管理、聊天交互、模型管理、参数管理及用户界面。各模块通过明确的API接口契约进行通信，并通过共享的Redis缓存层（用于历史消息）和前端状态管理库（Pinia）维持数据的一致性。以下将逐一对各模块的职责、核心类&#x2F;组件设计、关键算法与逻辑流程、以及对外接口进行详细说明，旨在为开发实现提供清晰、无歧义的蓝图</p>
<h2 id="3-1认证模块"><a href="#3-1认证模块" class="headerlink" title="3.1认证模块"></a>3.1认证模块</h2><p><strong>功能描述</strong>：提供登录认证，用户输入正确的账号和密码方可进入系统</p>
<p><strong>实现细节</strong>：</p>
<p>l 前端用户输入账号和密码，点击登录按钮；</p>
<p>l 前端向后端请求 &#x2F;api&#x2F;login，发送账号和密码；</p>
<p>l 后端校验账号和密码；</p>
<p>l 如果匹配，则生成一个简单的会话 token返回前端。如果不匹配，则返回错误信息。</p>
<p>l 前端保存登录状态（存储在 localStorage）。</p>
<p>l 后续接口请求中，前端在请求头中附带 token，后端验证 token 有效性。</p>
<p><strong>接口设计：</strong></p>
<table>
<thead>
<tr>
<th>URL：POST &#x2F;api&#x2F;login</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>说明</td>
</tr>
<tr>
<td>请求：</td>
<td>username</td>
<td>String</td>
<td>是</td>
<td>用户名</td>
</tr>
<tr>
<td></td>
<td>password</td>
<td>String</td>
<td>是</td>
<td>密码</td>
</tr>
<tr>
<td>响应：</td>
<td>message</td>
<td>String</td>
<td></td>
<td>登录结果提示信息</td>
</tr>
<tr>
<td></td>
<td>User_id</td>
<td>String</td>
<td></td>
<td>用户唯一标识，由后端生成并存储在Cookie中</td>
</tr>
</tbody></table>
<h2 id="3-2会话管理模块"><a href="#3-2会话管理模块" class="headerlink" title="3.2会话管理模块"></a>3.2会话管理模块</h2><p><strong>功能描述</strong>：支持多会话管理，用户可以创建、删除会话。每个会话独立保存聊天记录，用户可在不同会话之间自由切换，导出历史对话为 Markdown 或 JSON 文件。</p>
<p><strong>实现细节：</strong></p>
<p>（1）创建、删除会话：新建对话，openDialog()提示输入会话标题。点击确认（confirmNew()）后调用store.newConversation(title)创建新的会话。删除会话，调用store.deleteConversation(id)删除对应(id)的会话，若删除当前会话，自动切换到下一个可用会话。</p>
<p>（2）导出会话：用户点击“导出为Markdown”按钮，系统调用chatStore.exportCurrentConversationAsMarkdown()，将当前会话的消息整理为 Markdown 格式字符串，生成下载链接和文件名；用户点击“导出为JSON”按钮，系统调用chatStore.exportCurrentConversationAsJson()，将当前会话的消息序列化为 JSON 字符串, 生成下载链接和文件名；生成 Blob 数据并创建下载链接（URL.createObjectURL），动态创建一个不可见 标签，设置 href 和 download 属性。自动触发点击事件，完成文件下载。删除 标签，清理 DOM。</p>
<h2 id="3-3聊天交互模块"><a href="#3-3聊天交互模块" class="headerlink" title="3.3聊天交互模块"></a>3.3聊天交互模块</h2><p><strong>功能描述</strong>：提供生成式智能问答会话窗口，支持两种输入方式（文本\文档），调用LLM，接收问题并显示回复，并支持对响应及输出速度的记录。</p>
<p><strong>实现细节</strong>：</p>
<p>（1）智能问答：</p>
<p>l 前端构建用户信息，向后端请求&#x2F;api&#x2F;chat，携带对话信息;</p>
<p>l 后端接收请求，调用transformers库导入AutoModelForCausalLM, AutoTokenizer加载本地LLM，使用apply_chat_template()构建promp，合并history历史消息；</p>
<p>l 后端调用generate_reponse()执行模型生成[model.generate()或model.chat()]，返回响应response，将本次响应合并至history历史消息。</p>
<p>l 前端解析回复，计算耗时，更新UI，展示问答结果、响应时间，清空输入框，允许下一次输入。</p>
<p>（2）文档处理：</p>
<p>l 前端选择文件，支持TXT、MD格式，调用uploadFIle()，生成 FormData，通过 axios 发送到 &#x2F;api&#x2F;upload；</p>
<p>l 后端接收请求，检验格式，临时保存并读取文本text；</p>
<p>l 后端将text合并至history历史消息，返回文档加载成功响应；</p>
<p>l 前端接收响应，更新UI（显示文件名以及成功加载文档提示）。</p>
<p><strong>接口设计：</strong></p>
<table>
<thead>
<tr>
<th>URL：POST &#x2F;api&#x2F;chat</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>说明</td>
</tr>
<tr>
<td>请求：</td>
<td>Messages</td>
<td>Array</td>
<td>是</td>
<td>历史消息列表，每个元素包含role(user&#x2F;assistant)和content</td>
</tr>
<tr>
<td></td>
<td>currentMessage</td>
<td>Object</td>
<td>是</td>
<td>当前用户消息对象，结构为{role:”user”,content:”…”}</td>
</tr>
<tr>
<td>响应：</td>
<td>Response</td>
<td>String</td>
<td></td>
<td>智能问答生成的回复内容</td>
</tr>
<tr>
<td></td>
<td>User_id</td>
<td>String</td>
<td></td>
<td>用户唯一标识，由后端生成并存储在Cookie中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>URL：POST &#x2F;api&#x2F;upload</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>说明</td>
</tr>
<tr>
<td>请求：</td>
<td>File</td>
<td>File</td>
<td>是</td>
<td>需上传的文件，支持.txt和.md</td>
</tr>
<tr>
<td>响应：</td>
<td>Message</td>
<td>String</td>
<td></td>
<td>上传结果提示信息，“上传成功”</td>
</tr>
<tr>
<td></td>
<td>Text_preview</td>
<td>String</td>
<td></td>
<td>文件内容前200个字符的预览</td>
</tr>
<tr>
<td></td>
<td>User_id</td>
<td>String</td>
<td></td>
<td>用户唯一标识，由后端生成并存储在Cookie中</td>
</tr>
</tbody></table>
<h2 id="3-4模型管理模块"><a href="#3-4模型管理模块" class="headerlink" title="3.4模型管理模块"></a>3.4模型管理模块</h2><p><strong>功能描述</strong>：用户可在多个大语言模型（Qwen、Baichuan、Yi、Mistral、Zephyr、九格）之间切换，同时支持API调用模型，系统自动应用至后续问答。</p>
<p><strong>实现细节</strong>：</p>
<p>（1）加载模型</p>
<p>l 前端页面加载时，向后端请求&#x2F;api&#x2F;get_model；</p>
<p>l 后端接收请求&#x2F;api&#x2F;get_model，返回current_model；</p>
<p>l 前端调用 store.setModel(res.data.model) 将当前使用的模型写入全局状态。</p>
<p>（2）切换模型</p>
<p>l 切换模型触发onChange(val)，向后端请求&#x2F;api&#x2F;set_model；</p>
<p>l 后端接收请求&#x2F;api&#x2F;set_model，更新current_model[“model”]，调用chatbot.set_model(model_name) 让底层问答逻辑切换到对应模型。返回响应。如果选择API调用模型的方式，则需要使用正确的URL及用户密钥，实现正确调用。</p>
<p>l 如果成功，更新前端全局状态并提示“模型切换成功”；如果失败，提示“模型切换失败”。</p>
<p><strong>接口设计：</strong></p>
<table>
<thead>
<tr>
<th>URL: GET &#x2F;api&#x2F;get_model</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>说明</td>
</tr>
<tr>
<td>响应：</td>
<td>model</td>
<td>String</td>
<td>当前正在使用的模型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>URL: POST&#x2F;api&#x2F;set_model</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>说明</td>
</tr>
<tr>
<td>请求：</td>
<td>model</td>
<td>String</td>
<td>是</td>
<td>目标模型名称</td>
</tr>
<tr>
<td>响应：</td>
<td>message</td>
<td>String</td>
<td></td>
<td>操作结果提示，例如“模型切换成功”</td>
</tr>
<tr>
<td></td>
<td>error</td>
<td>String</td>
<td></td>
<td>错误信息（仅失败时返回）</td>
</tr>
</tbody></table>
<h2 id="3-5参数管理模块"><a href="#3-5参数管理模块" class="headerlink" title="3.5参数管理模块"></a>3.5参数管理模块</h2><p><strong>功能描述</strong>：用户可调整推理参数，包括：temperature、top_p、top_k、max_length，控制模型的输出效果。</p>
<p><strong>实现细节</strong>：</p>
<p>（1）配置参数</p>
<p>l 前端页面加载时（onMounted），向后端请求 &#x2F;api&#x2F;get_parameters；</p>
<p>l 后端从 chatbot.parameters 中取出当前参数，将其打包为 JSON 返回；</p>
<p>l 前端逐字段写入 settingStore，避免覆盖本地已有的持久化字段。</p>
<p>（2）修改参数</p>
<p>l 用户在界面上调整参数后，调用 sendParameters()，向后端请求&#x2F;api&#x2F;change_parameters；</p>
<p>l 后端调用 chatbot.set_parameters(…)，依次更新 temperature、top_p、max_length、top_k等，并返回操作信息；</p>
<p>l 成功时提示“参数应用成功”，失败时提示“发送参数时出错，请重试”。</p>
<p><strong>接口设计：</strong></p>
<table>
<thead>
<tr>
<th>URL: GET &#x2F;api&#x2F;get_ parameters</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>说明</td>
</tr>
<tr>
<td>响应：</td>
<td>temperature</td>
<td>Float</td>
<td>采样温度，控制多样性</td>
</tr>
<tr>
<td></td>
<td>top_k</td>
<td>Integer</td>
<td>Top-K采样值</td>
</tr>
<tr>
<td></td>
<td>top_p</td>
<td>Float</td>
<td>Top-P 采样概率</td>
</tr>
<tr>
<td></td>
<td>max_length</td>
<td>Integer</td>
<td>最大生成长度</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>URL: POST&#x2F;api&#x2F;change_ parameters</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>字段名</td>
<td>类型</td>
<td>必填</td>
<td>说明</td>
</tr>
<tr>
<td>请求：</td>
<td>temperature</td>
<td>Float</td>
<td>否</td>
<td>采样温度，控制多样性，数值越大越随机</td>
</tr>
<tr>
<td></td>
<td>top_k</td>
<td>Integer</td>
<td>否</td>
<td>Top-K采样值</td>
</tr>
<tr>
<td></td>
<td>top_p</td>
<td>Float</td>
<td>否</td>
<td>Top-P 采样概率</td>
</tr>
<tr>
<td></td>
<td>max_length</td>
<td>Integer</td>
<td>否</td>
<td>最大生成长度</td>
</tr>
<tr>
<td>响应：</td>
<td>message</td>
<td>String</td>
<td></td>
<td>操作结果提示</td>
</tr>
</tbody></table>
<h2 id="3-6用户界面模块"><a href="#3-6用户界面模块" class="headerlink" title="3.6用户界面模块"></a>3.6用户界面模块</h2><p><strong>功能描述</strong>：提供图形化人机交互界面。</p>
<p><strong>组件设计：</strong></p>
<p>（1）登录窗口: 账号、密码输入框。</p>
<p>（2）主聊天窗口:</p>
<p>l 侧边栏: 会话列表、“新建会话”、“删除会话”按钮。</p>
<p>l 主区域: 对话显示区域（带时间戳）、输入框（支持文本和文件上传）、发送按钮。</p>
<p>l 顶部工具栏: 模型选择框、设置界面展开按钮（设置界面包括参数设置框、导出历史消息按钮）。</p>
<p>（3）参数设置框: 滑块或输入框用于调整temperature、top_p、max_length等参数。</p>
<p>（4）历史消息下载：提供选项，包括：导出JSON格式历史消息、导出markdown格式历史消息。</p>
<h1 id="四、数据设计"><a href="#四、数据设计" class="headerlink" title="四、数据设计"></a>四、数据设计</h1><p>本章节旨在详细定义系统中数据的核心形态、组织结构、生命周期与流转路径。作为一款强调隐私与独立的私有化部署应用，系统在设计上刻意避免了对传统关系型数据库的长期依赖。运行时的核心数据动态存在于应用程序的内存空间中，并主要通过精心设计的前端状态容器与后端业务对象进行管理与交互。系统的持久化机制体现为两种形式：一是启动时读取的静态配置文件，二是由用户主动触发的对话历史导出文件。本次设计的核心演进在于引入 Redis 作为高性能的内存数据存储，专门用于负责聊天历史消息的持久化缓存，这解决了纯内存存储无法在服务重启后保留上下文，以及难以支撑海量历史数据的问题。整体数据设计将紧密围绕前端 Pinia Store、后端业务状态与 Redis 缓存三者之间的高效、一致同步来展开，并对关键业务场景下的数据流动细节进行深入阐述。</p>
<h2 id="4-1-运行时数据结构"><a href="#4-1-运行时数据结构" class="headerlink" title="4.1 运行时数据结构"></a>4.1 运行时数据结构</h2><p>系统的运行时数据是一个由前端状态、后端业务状态与 Redis 缓存共同构成的协同体系，通过清晰的 RESTful API 契约进行通信和状态同步。</p>
<p><strong>前端状态管理</strong> <strong>(基于Pinia)</strong> </p>
<p>前端采用 Vue 3 的组合式 API 与 Pinia 状态管理库，通过模块化、响应式的 Store 来构建应用的客户端数据模型。这些 Store 不仅是 UI 渲染的数据源，也负责封装与用户交互相关的业务逻辑。</p>
<p>（1）聊天会话存储 (ChatStore): 此 Store 是前端交互状态的核心，管理着用户所有的对话会话及其消息流。它内部维护着一个响应式的会话列表，其中每个会话对象都包含由 nanoid 生成的唯一标识符、一个可读的标题以及构成该对话的所有消息数组。通过一个指向当前活动会话 ID 的响应式引用，以及基于此 ID 派生的计算属性，视图可以轻松获取并渲染当前会话的完整内容。该 Store 提供了一组原子操作方法，例如创建新会话、在会话间切换、向特定会话添加或删除消息，以及删除整个会话。一个关键特性是，该 Store 的所有状态都被配置为持久化，利用浏览器的 localStorage 机制，确保在页面意外刷新或重新打开后，用户的会话列表和消息内容能够得以恢复，提供了连续的用户体验。</p>
<p>（2）模型与参数存储 (ModelStore &amp; SettingStore): 为了模块化分离关注点，模型选择与生成参数的管理被分配至独立的 Store。ModelStore 负责跟踪当前用户选中的大语言模型标识符（如 “qwen”），而 SettingStore 则管理着一组影响模型生成行为的参数，例如控制创造性的 temperature、影响采样范围的 top_p 和 top_k，以及决定生成长度的 max_length。用户通过下拉框或滑动条进行的调整会即时更新这些 Store 中的状态。同样，这些偏好设置也进行了持久化，保证用户下一次访问应用时，其熟悉的模型和参数配置能够自动生效。</p>
<p><strong>后端业务状态与</strong> <strong>Redis</strong> <strong>缓存</strong></p>
<p>后端采用面向对象的设计，通过 Python 类来封装核心业务逻辑和状态。与前端 Store 对应，后端维护着服务端的权威状态。</p>
<p>（1）核心业务状态: 后端的核心状态由诸如 ModelManager 这样的管理器类持有。它记录了当前系统活跃的模型标识、全局的模型生成参数配置等元信息。这些信息在应用启动时从配置文件加载，并在运行中通过 API 接收前端的更新。</p>
<p>（2）历史消息的 Redis 缓存策略: 这是数据设计的重大增强。系统不再将用户的历史对话消息完全保存在后端进程的内存变量中，而是引入 Redis 作为专门的、持久化的历史消息存储层。每一个独立的聊天会话在 Redis 中都有一个唯一的键与之对应，该键通常由用户标识与会话 ID 组合而成，其值是一个列表（List）或有序集合（Sorted Set），按序存储着该会话中所有交互消息的 JSON 序列化字符串。这种设计带来了多重优势：首先，它确保了对话历史在应用程序重启后不会丢失，实现了会话的长期连续性；其次，它将海量的历史数据从应用服务器内存中剥离，显著降低了后端的内存压力，提升了系统稳定性；最后，Redis 卓越的读写性能保障了在多次长对话场景下，历史上下文的拼接与检索速度极快，几乎不会成为性能瓶颈。</p>
<h2 id="4-2-关键业务场景数据流"><a href="#4-2-关键业务场景数据流" class="headerlink" title="4.2 关键业务场景数据流"></a>4.2 关键业务场景数据流</h2><p>以下描述几个核心用户操作背后，数据在前后端及 Redis 之间的完整流动过程：</p>
<p>（1）用户发送一条新消息：</p>
<p><strong>前端发起</strong>:用户在界面输入消息并点击发送。ChatStore 中的动作方法会首先在本地 optimistic 地添加一条状态为“发送中”的用户消息到当前会话，以提供即时反馈。随后，通过 Axios 将消息内容、当前会话 ID 以及当前的模型和参数设置封装成 JSON，发送至后端 &#x2F;api&#x2F;chat 端点。</p>
<p><strong>后端处理与 Redis 交互:</strong> Flask 路由接收到请求。</p>
<p>a. 历史获取: 根据请求中的会话 ID，后端服务会首先访问 Redis，读取该会话对应的完整历史消息列表，并将其反序列化。</p>
<p>b. 上下文组装: 将新的用户消息追加到检索到的历史列表中，形成本次模型调用所需的完整上下文提示（Prompt）。</p>
<p>c. 模型推理: 调用 ModelManager 的统一接口，将组装好的上下文和参数传递给指定的大语言模型进行文本生成。</p>
<p>d. 历史回写与响应: 模型生成完成后，后端将新产生的助手回复追加到历史列表中，并立即将更新后的整个历史列表序列化后写回 Redis 中的对应键，完成持久化。最后，将助手生成的内容封装成 API 响应返回给前端。</p>
<p><strong>前端更新</strong>: 前端收到成功响应后，将本地之前添加的“发送中”消息更新为正式消息，并紧接着将返回的助手回复添加到当前会话的消息列表中，完成 UI 的最终渲染。</p>
<p>（2）用户切换对话模型：</p>
<p>a. 用户在前端下拉菜单中选择一个新模型（如从 “qwen” 切换为 “baichuan”）。</p>
<p>b. ModelStore 中的 currentModel 状态立即更新，并通过持久化插件保存到 localStorage。</p>
<p>c. 此状态更改是全局性的。它不会影响 Redis 中已存储的任何历史消息内容，也不会追溯改变已生成的消息。然而，自此之后，任何新发起的 &#x2F;api&#x2F;chat 请求都会携带这个新的模型标识符，后端将据此加载和调用对应的模型进行后续生成，从而实现模型在会话中的动态切换。</p>
<p>（3）应用启动与状态同步：</p>
<p>a. 当用户首次在浏览器中访问应用或刷新页面时，前端 Pinia Store 会从 localStorage 自动水合（hydrate）其状态，恢复出会话列表、上次使用的模型和参数。</p>
<p>b. 同时，前端应用在初始化阶段（如在根组件的 onMounted 钩子中）会向后端发起一个轻量的初始化请求（例如 GET &#x2F;api&#x2F;init）。</p>
<p>c. 后端在该接口中，可以返回系统层面的最新配置或状态（例如默认模型是否有更新），前端据此对本地 Store 进行必要的校正，确保客户端状态与服务器端权威配置保持一致。</p>
<h2 id="4-3-数据持久化与同步策略"><a href="#4-3-数据持久化与同步策略" class="headerlink" title="4.3 数据持久化与同步策略"></a>4.3 数据持久化与同步策略</h2><p>系统的数据持久化分为三个层次，共同保障数据的可靠性与用户操作的连续性：</p>
<p><strong>Redis</strong> <strong>持久化</strong> **(对话历史)：**作为对话历史的核心存储，Redis 可以配置为将内存数据定期快照或追加日志到磁盘，确保即使服务重启，所有聊天记录也能完好无损。这是保证“会话连续性”这一核心用户体验的基石。</p>
<p><strong>浏览器本地存储</strong> <strong>(前端状态)</strong>：Pinia Store 的持久化插件将用户的界面状态（如打开的会话标签、选中的模型、调整的参数）保存在浏览器的 localStorage 中。这属于“用户偏好”的持久化，主要服务于单设备上的体验连贯性，与 Redis 中存储的实质性对话内容互为补充。</p>
<p><strong>配置文件与用户导出文件</strong> <strong>(静态持久化)：</strong></p>
<p>（1）配置文件：以 YAML 或 JSON 格式存在于部署目录，存储应用启动所需的基础配置，如 Redis 连接参数、初始模型路径、管理员凭证的哈希值等。它在应用启动时被一次性读入内存。</p>
<p>（2）用户导出文件：用户通过前端的导出功能，可以将会话历史从当前 Pinia Store 或直接通过 API 从 Redis 中提取的数据，生成为 Markdown 或 JSON 格式的文件并下载到本地。这是用户自主控制的、脱离系统的长期存档方式。</p>
<p>状态同步：在本设计中，前端 Pinia Store 被视为“视图模型”或“用户交互状态的缓存”，其核心目标是保证 UI 的快速响应和流畅交互。后端的业务对象与 Redis 共同构成了系统数据的“单一可信源”。任何意图改变持久化状态的操作（如发送消息、创建会话），都必须通过后端 API 来执行，由后端负责原子性地更新 Redis 及内部状态，并将结果返回，前端再据此乐观地更新本地 Store。这种模式有效避免了数据不一致和状态冲突。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Zheng Yufeng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/12/20/local-llm2/">http://example.com/2025/12/20/local-llm2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Yufeng's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/Interactive-system/">Interactive system</a></div><div class="post-share"><div class="social-share" data-image="/image/local_llm.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/20/local-llm/" title="local_llm（用户操作手册）"><img class="cover" src="/image/local_llm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">local_llm（用户操作手册）</div></div><div class="info-2"><div class="info-item-1">用户操作手册：使用Flask+VUE搭建本地大语言模型</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/20/local-llm/" title="local_llm（用户操作手册）"><img class="cover" src="/image/local_llm.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">local_llm（用户操作手册）</div></div><div class="info-2"><div class="info-item-1">用户操作手册：使用Flask+VUE搭建本地大语言模型</div></div></div></a><a class="pagination-related" href="/2025/12/19/DYY2/" title="DYY(二)"><img class="cover" src="/image/watermark_text.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-19</div><div class="info-item-2">DYY(二)</div></div><div class="info-2"><div class="info-item-1">大语言模型水印展示平台</div></div></div></a><a class="pagination-related" href="/2025/12/19/2025-12-19-DYY(%E4%B8%89)/" title="DYY(三)"><img class="cover" src="/image/watermark_text.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-19</div><div class="info-item-2">DYY(三)</div></div><div class="info-2"><div class="info-item-1">大语言模型水印展示平台</div></div></div></a><a class="pagination-related" href="/2025/12/19/2025-12-19-DYY(%E4%B8%80)/" title="DYY(一)"><img class="cover" src="/image/watermark_text.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-19</div><div class="info-item-2">DYY(一)</div></div><div class="info-2"><div class="info-item-1">大语言模型水印展示平台</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Zheng Yufeng</div><div class="author-info-description">计算机技术专业，人工智能安全领域</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Zheng-Yu-feng"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Zheng-Yu-feng" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhengyufeng1010@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">此博客正处于完善阶段，期待您的宝贵意见</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">二、总体设计概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 系统架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">2.2.</span> <span class="toc-text">2.2技术栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E8%80%83%E8%99%91"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 关键设计考虑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">三、模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">3.1认证模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">3.2.</span> <span class="toc-text">3.2会话管理模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E8%81%8A%E5%A4%A9%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9D%97"><span class="toc-number">3.3.</span> <span class="toc-text">3.3聊天交互模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E6%A8%A1%E5%9E%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">3.4.</span> <span class="toc-text">3.4模型管理模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E5%8F%82%E6%95%B0%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97"><span class="toc-number">3.5.</span> <span class="toc-text">3.5参数管理模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E6%A8%A1%E5%9D%97"><span class="toc-number">3.6.</span> <span class="toc-text">3.6用户界面模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">四、数据设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 运行时数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%85%B3%E9%94%AE%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 关键业务场景数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 数据持久化与同步策略</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/local-llm2/" title="local_llm（详细设计）"><img src="/image/local_llm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="local_llm（详细设计）"/></a><div class="content"><a class="title" href="/2025/12/20/local-llm2/" title="local_llm（详细设计）">local_llm（详细设计）</a><time datetime="2025-12-20T08:05:15.000Z" title="发表于 2025-12-20 16:05:15">2025-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/local-llm/" title="local_llm（用户操作手册）"><img src="/image/local_llm.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="local_llm（用户操作手册）"/></a><div class="content"><a class="title" href="/2025/12/20/local-llm/" title="local_llm（用户操作手册）">local_llm（用户操作手册）</a><time datetime="2025-12-20T07:04:14.000Z" title="发表于 2025-12-20 15:04:14">2025-12-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/local_llm.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Zheng Yufeng</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div></div></body></html>